# Over the Rainbow

## このドキュメントについて


42cursusのCTF系課題 Rainfall, Override に挑むにあたり, さしあたって必要と思われる知識をまとめたもの。

## CTF系課題について

2023年10月1日現在, 42Tokyoで常設されているCTF系課題は以下の3つ:

- snow-crash
- **rainfall**
- **override**

(boot2rootなどはセキュリティ系ではあるがCTF系ではないとする)

これら3つのうち, snow-crashはネタの種類が入り乱れているが, rainfallとoverrideに関しては
ほぼ一貫してx86(64)バイナリに対する攻撃が出題される.\
(ただし snow-crash にもバイナリ問題はある)

## Rainfall, Override 課題概要

ひとことで: **「脆弱性を持つバイナリを使って権限昇格を行い, パスワードを抜き取る」**

- 課題ページで Linux の Live CD(のisoイメージ)が配布されているので, Virtual Box などでこれを起動する.
- 10問~ 程度の独立した小問題(レベル)からなる.
- 初期状態で挑戦できるのは最初のレベルだけであり, それを解く(=フラグ文字列を得る)と次のレベルに挑戦できるようになる.
- 各レベルにはそれぞれユーザが対応する.
    - 例: 最初のレベル`level0`には, ユーザ`level0`が対応する.
- 各ユーザがアクセスできる領域は制限されている:
    - ユーザ自身のホームディレクトリ
    - `/tmp`以下
        - 読み書き可能だが, 一覧表示はできない
    - 環境変数`PATH`に含まれる各ディレクトリ
- 各ユーザのホームディレクトリには, ユーザと同名のバイナリが1つだけ置いてある.
    - 例: ユーザ`level0`にログインすると, バイナリ`level0`が置いてある.
- また, `level0`以外のユーザについては, フラグファイル`.pass`も置いてある. これはそのユーザのログインパスワードになっている.
    - 例: ユーザ`level1`のホームディレクトリには`.pass`ファイルがあり, その中身はユーザ`level1`のログインパスワードである.
- このバイナリは「次のレベルのユーザ」に`setuid`されている.
    - 例: バイナリ`level0`はユーザ`level1`に`setuid`されているので, 実行するとユーザ`level1`の権限で動く.
- 各レベルでの最終目的は「次のレベルの`.pass`の中身を知ること」である.


## 全体マップ

- C言語 *このドキュメントの対象外*
- アセンブリ言語
- メモリの構造
- 攻撃手法
- 防御メカニズム
- ツール群


### スタックにまつわる用語

- スタックフレーム
- リターンアドレス
- ベースポインタ
- スタックポインタ

の4用語について, 互いの関連性を含めてまとめて説明する。

<img src="images/stack_frame.png">

「スタックフレーム」は、スタックのうち特定の関数呼び出しに対応する区間のこと。

「リターンアドレス」は、呼び出されている関数が終了(つまり`return`)した後、
それに続けて実行される命令のアドレス。\
平たく言えば「リターンした後の行き先」。

これら2つは、呼び出されたまま終了していない関数と同じ数だけ存在する。

「スタックポインタ」は, プロセスのアドレス空間において「スタックのトップ」にあたるアドレスを指しているポインタのこと。\
しばしばアドレスそのものも指す。\
x86(x86_64)においては`esp`(`rsp`)レジスタがスタックポインタ。

「ベースポインタ」は, 現在実行されている関数のスタックフレームにおける「スタックの底」を指しているポインタのこと。\
これもしばしばアドレスそのものを意味する。\
x86(x86_64)においては`ebp`(`rbp`)レジスタがスタックポインタ。

### リターンアドレスの書き換えについて

`main`から`some_func`を呼び出している時のスタックの様子:

<img src="images/return_address_rewriting.png">

`some_func`のスタックフレームにおいて, `some_func`からのリターンアドレスはスタックフレームの一番上(アドレスの大きい側)にある。\
一方, `some_func`のローカル変数はスタックフレームの低位側(アドレスの小さい側)にある。

→ あるローカル配列に対して, 配列の長さを超えたところに書き込みができる場合, リターンアドレスを変更できる可能性がある。


### バッファオーバーランとスタックスマッシング

<img src="images/overrun.png">

### フォーマット文字列攻撃

`printf`系関数のフォーマット文字列にユーザが干渉できると, かなりデカ目の脆弱性になる。

知りたい情報がprintfのスタックフレームより上(高位側)にある時,\
格納されているアドレス(正確には, printfのベースポインタからの相対位置)さえわかれば,\
`$`による位置指定を使ってその情報を直接表示することができる。

<img src="images/format_string_attack_1.png">


---

この攻撃が真価を発揮するのはデータの書き込み。

<img src="images/format_string_attack_2.png">

フォーマット文字列の長さに十分な余裕があるなら, ほぼ任意のアドレスに対してほぼ任意のデータをピンポイントで書き込むことができる。\
制限事項は:

1. フォーマット文字列の長さが, 書き込みを実現できるほど長いこと
1. 書き込むデータが`INT_MAX`を超えないこと
    - これについては, `%n`で一気に書き込まず, `%hn`で2バイトずつ2回に分けて書き込むことで回避可能.

脆弱性が存在する場合, 書き込み自体を防ぐことは難しい。\
ただし, ASLRにより「書き込み先のアドレス」および「書き込むべきアドレス」を予測しにくくすることはできる。



### return-to-libc 攻撃

### シェルコード
